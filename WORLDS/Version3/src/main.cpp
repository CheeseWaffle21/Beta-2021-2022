// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   C               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// expander             triport       11              
// tilter               digital_out   D               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   C               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// expander             triport       11              
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// expander             triport       11              
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// expander             triport       11              
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// expander             triport       11              
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// Expander2            triport       2               
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// arm                  motor         16              
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         14              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         20              
// boostleft            motor         13              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         6               
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         20              
// boostleft            motor         12              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         11              
// backright            motor         10              
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         20              
// boostleft            motor         12              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         11              
// backright            motor         9               
// frontright           motor         8               
// Controller1          controller                    
// boostright           motor         20              
// boostleft            motor         12              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// ---- END VEXCODE CONFIGURED DEVICES ----
// ---- START VEXCODE CONFIGURED DEVICES ----
// Robot Configuration:
// [Name]               [Type]        [Port(s)]
// frontleft            motor         7               
// backleft             motor         11              
// backright            motor         9               
// frontright           motor         10              
// Controller1          controller                    
// boostright           motor         20              
// boostleft            motor         12              
// clamp                digital_out   F               
// intertia             inertial      1               
// righttracker         encoder       A, B            
// lefttracker          encoder       G, H            
// ---- END VEXCODE CONFIGURED DEVICES ----
#include "vex.h"
#include <math.h>
#include <cmath>


double pi = 3.14159;

using namespace vex;

// A global instance of competition
competition Competition;

// define your global instances of motors and other devices here

void setall (int speed, vex::percentUnits units) {
  frontright.setVelocity(speed, units);
  frontleft.setVelocity(speed, units);
  backleft.setVelocity(speed, units);
  backright.setVelocity(speed, units);
  boostleft.setVelocity(speed, units);
  boostright.setVelocity(speed, units);
}

void setallright (int speed, vex::percentUnits units) {
  backright.setVelocity(speed, units);
  frontright.setVelocity(speed, units);
  boostright.setVelocity(speed, units);
}

void setallleft (int speed, vex::percentUnits units) {
  backleft.setVelocity(speed, units);
  frontleft.setVelocity(speed, units);
  boostleft.setVelocity(speed, units);
}

void kill () {
  backleft.stop(hold);
  frontleft.stop(hold);
  backright.stop(hold);
  frontright.stop(hold);
  boostleft.stop(hold);
  boostright.stop(hold);
}

void spinall () {
  backleft.spin(forward);
  frontleft.spin(forward);
  backright.spin(forward);
  frontright.spin(forward);
  boostleft.spin(forward);
  boostright.spin(forward);
}


/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the V5 has been powered on and        */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton(void) {
  // Initializing Robot Configuration. DO NOT REMOVE!
  vexcodeInit();

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...

  //Sensor actions
  //intertia.calibrate();
  righttracker.setPosition(0, degrees);
  lefttracker.setPosition(0, degrees);
  backleft.resetPosition();
  backright.resetPosition();
  frontright.resetPosition();
  frontleft.resetPosition();
  boostleft.resetPosition();
  boostright.resetPosition();
  arm.resetPosition();
}

//Variables for autonomous
double trackingWheelRadius = 2.75 / 2;
double trackingDistanceLeft = 3;
double trackingDistanceRight = 3;

struct robotpositions {
  double robotx;
  double roboty;
  double robotangle;
};
robotpositions robotposition;

//Tasks for autonomous

double radian (double number) {
  return (number / 180) * pi;
}

double degree (double number) {
  return (number * 180) / pi;
}

double leftposition () {
  return radian(lefttracker.position(degrees)) * trackingWheelRadius;
}

double rightposition () {
  return radian(righttracker.position(degrees)) * trackingWheelRadius;
}

double getheading () {
  return ( leftposition() - rightposition() ) / ( trackingDistanceRight + trackingDistanceLeft );
}

robotpositions getlocation () {
  double headingangle = getheading();
  double rightvalue = rightposition();
  double leftvalue = leftposition();
  double radius = ( ( rightvalue * trackingDistanceLeft ) + ( leftvalue * trackingDistanceRight ) ) / ( leftvalue - rightvalue );
  double hypotenuse = sqrt( pow(radius, 2) + pow(radius, 2) - ( 2 * radius * radius * cos(headingangle) ) );
  double x = hypotenuse * ( cos( (180 - headingangle) / 2) );
  double y = hypotenuse * ( sin( (180 - headingangle) / 2) );
  
  robotposition.robotx = x;
  robotposition.roboty = y;
  robotposition.robotangle = headingangle;

  return robotposition;
}

int printinfo () {
  int rownumber = 1;
  int colnumber = 1;
  while (true) { 
    Brain.Screen.clearScreen();

    Brain.Screen.setCursor(rownumber, colnumber);
    rownumber ++;
    Brain.Screen.print("Left tracker value: %f", leftposition());

    Brain.Screen.setCursor(rownumber, colnumber);
    rownumber ++;
    Brain.Screen.print("Right tracker value: %f", rightposition());

    Brain.Screen.setCursor(rownumber, colnumber);
    rownumber ++;
    Brain.Screen.print("X: %f", robotposition.robotx);
    
    Brain.Screen.setCursor(rownumber, colnumber);
    rownumber ++;
    Brain.Screen.print("Y: %f", robotposition.roboty);

    Brain.Screen.setCursor(rownumber, colnumber);
    rownumber ++;
    Brain.Screen.print("Heading radians: %f", robotposition.robotangle);

    Brain.Screen.setCursor(rownumber, colnumber);
    rownumber ++;
    Brain.Screen.print("Heading degrees: %f", degree(robotposition.robotangle));
    
    wait(20, msec);
    rownumber = 1;
    colnumber = 1;   
  }
  return 0;
}

void gotocoord(double x, double y){  
  /*This function just does simple moving to coordinates by rotating first, then traveling, 
  without rotating back to the original orientation.

  This is subject to develop to account for curves, PID, any other fancy thing
  
  Heading angle used here is based off of encoders only, though in loose undeveloped theory, 
  the inertial sensor can be used as well since its angle is just half of the arc angle thing*/

  double dispx = x - robotposition.robotx;
  double dispy = y - robotposition.roboty;

  double angledestination = (2*(90 - (atan(dispy/dispx)))) + robotposition.robotangle; //If inertial sensor is used, omit the '2*' in the beginning.

  

//Rotating part
  if (angledestination - robotposition.robotangle >= 0) {

  while(true) {
    backleft.setVelocity(30, percent);
    frontleft.setVelocity(30, percent);
    backright.setVelocity(-30, percent);
    frontright.setVelocity(-30, percent);

    if (fabs(robotposition.robotangle) >= fabs(angledestination)) { //Absolute value not needed in this if clause, but it makes copying and pasting to the 'else' clause easier
      kill();
      break;
    }
  }
  }

if (angledestination - robotposition.robotangle < 0) {
  while(true) {
    backleft.setVelocity(-30, percent);
    frontleft.setVelocity(-30, percent);
    backright.setVelocity(30, percent);
    frontright.setVelocity(30, percent);

    if (fabs(robotposition.robotangle) >= fabs(angledestination)) { //Absolute value not needed in this if clause, but it makes copying and pasting to the 'else' clause easier
      kill();
      break;
    }
  }
}

//Moving forward part
  while(true) {
    setall(40, percent);
    spinall();

    if (robotposition.robotx >= dispx || robotposition.roboty >= dispy){
      kill();
      break;
    }

  }

}



/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

void autonomous(void) {
  // ..........................................................................
  // Insert autonomous user code here.
  // ..........................................................................
  task mytask = task(printinfo);
  while (true) {
    getlocation();
    wait(20, msec);
  }

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
int threshold = 10; //tune
int front = 0;
int rotate = 0;
int leftspeed = 0;
int rightspeed = 0;

int shared = 0;
bool sharedmoving = false;

bool armmoving = false;

bool clamppressed = false;

bool tilterpressed = false;

void usercontrol(void) {
  arm.setVelocity(0, percent);
  task mytask = task(printinfo);
  while (1) {
    getlocation();

    front = Controller1.Axis3.position(percent);
    rotate = Controller1.Axis4.position(percent);

    if (front < threshold && front > -threshold) {
      front = 0;
    }
    if (rotate < threshold && rotate > -threshold) {
      rotate = 0;
    }

    Brain.Screen.setCursor(10, 1);
    Brain.Screen.print("Axis 3 (forwards-back): %d", front);
    Brain.Screen.setCursor(11, 1);
    Brain.Screen.print("Axis 1 (turning): %d", rotate);

    if (Controller1.ButtonL1.pressing()) {
      shared = -40;
      sharedmoving = true;
    } else if (Controller1.ButtonL2.pressing()) {
      shared = 40;
      sharedmoving = true;
    } else if (sharedmoving) {
      shared = 0;
      sharedmoving = false;
    }
    
    frontright.setVelocity(front - rotate + shared, percent);
    frontleft.setVelocity(front + rotate + shared, percent);
    backleft.setVelocity(front + rotate - shared, percent);
    backright.setVelocity(front - rotate - shared, percent);
    boostleft.setVelocity(front + rotate, percent);
    boostright.setVelocity(front - rotate, percent);
    
    spinall();

    if (Controller1.ButtonR1.pressing()) {
      arm.setVelocity(-100, percent);
      armmoving = true;
    } else if (Controller1.ButtonR2.pressing()) {
      arm.setVelocity(100, percent);
      armmoving = true;
    } else if (armmoving) {
      arm.setVelocity(0, percent);
      arm.setBrake(hold);
      armmoving = false;
    }
    
    arm.spin(forward);
    
    if (Controller1.ButtonX.pressing() && !clamppressed) {
      clamp.set(!clamp.value());
      clamppressed = true;
    } else if (!Controller1.ButtonX.pressing()) {
      clamppressed = false;
    }

    if (Controller1.ButtonA.pressing() && !tilterpressed) {
      tilter.set(!tilter.value());
      tilterpressed = true;
    } else if (!Controller1.ButtonA.pressing()) {
      tilterpressed = false;
    }

    wait(20, msec); // Sleep the task for a short amount of time to
                    // prevent wasted resources.                 
  }
}

//
// Main will set up the competition functions and callbacks.
//
int main() {
  // Set up callbacks for autonomous and driver control periods.
  Competition.autonomous(autonomous);
  Competition.drivercontrol(usercontrol);

  // Run the pre-autonomous function.
  pre_auton();

  // Prevent main from exiting with an infinite loop.
  while (true) {
    wait(100, msec);
  }
  
}
